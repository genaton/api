*********************************************************************************
* ATENCAO!!!! ESTE DOCUMENTO NAO EH APENAS SOBRE A APLICACAO DESTE REPOSITORIO. *
*ELE TAMBÉM TRAZ ANOTACOES IMPORTANTES DO USO DO FRAMEWOR SPRING BOOT E DAS     *
*AULAS DO CURSO                                                                 *
*********************************************************************************

Objetivos
Desenvolvimento de uma API Rest
CRUD (Create, Read, Update e Delete)
Validações
Paginação e ordenação

Tecnologias
Spring Boot 3
Java 17
Lombok
MySQL/ Flyway
JPA/Hibernate
Maven
Insomnia

PROJETO

Trabalharemos em um projeto de uma clínica médica fictícia. Temos uma empresa chamada Voll Med, que possui uma clínica que precisa de um aplicativo para monitorar o cadastro de médicos, pacientes e agendamento de consultas.

Será um aplicativo com algumas opções, em que a pessoa que for usar pode fazer o CRUD, tanto de médicos quanto de pacientes e o agendamento e cancelamento das consultas.

Vamos disponibilizar esse protótipo, mas lembrando que é somente para consultas, para visualizarmos como seria o Front-end. Isso porque o foco deste curso é o Back-end.

A documentação das funcionalidades do projeto ficará em um quadro do Trello com cada uma das funcionalidades. Em cada cartão teremos a descrição de cada funcionalidade, com as regras e validações que vamos implementar ao longo do projeto.

Esse é o nosso objetivo neste curso, aprender a usar o Spring Boot na versão 3 para desenvolvermos o projeto dessa clínica médica, utilizando as tecnologias mencionadas anteriormente.
FIGMA https://www.figma.com/file/N4CgpJqsg7gjbKuDmra3EV/Voll.med?fuid=831333280461696730
TRELLO https://trello.com/b/O0lGCsKb/api-voll-med


O Spring Boot já traz o Tomcat configurado como gerenciador de coneccao (servidor).

Atencao!!!
Para a dependencia DevTools funcionar no Intelij eh necessahria a seguinte configuracao:
Va em Settings opção "Build, Execution, Deployment" para expandir. Nela, clicaremos na seção "Compiler", e à direita do menu, temos uma checkbox ("caixa de seleção") chamada "Build project automatically" ("Construir projeto automaticamente").

               Marcaremos a opção "Build project automatically" e depois vamos clicar no botão "Apply", no canto inferior direito da tela. Agora, voltando para o menu do lado esquerdo, clicaremos na opção "Advanced Settings" ("Configurações avançadas").

               Na página de configurações avançadas, marcaremos a opção "Allow auto-make to start even if developed application is currently running" ("Permitir que a criação automática inicie mesmo se o aplicativo desenvolvido estiver em execução no momento"), dentro da seção "Compiler".

               Logo após, podemos clicar no botão "Apply" e depois em "Ok", no canto inferior direito.

               No IntelliJ vamos parar o projeto e reiniciar só para garantirmos o pleno funcionamento. Para parar o projeto, clicaremos no botão com o ícone de um quadrado vermelho "▆" no canto superior direito. Após isso, vamos selecionar o ícone de play na cor verde "▶", para rodar a aplicação.

               Para saber mais: lidando com CORS:

               Quando desenvolvemos APIs e queremos que todos os seus recursos fiquem disponíveis a qualquer cliente HTTP, uma das coisas que vem à nossa cabeça é o CORS (Cross-Origin Resource Sharing), em português, “compartilhamento de recursos com origens diferentes”. Se ainda não aconteceu com você, fique tranquilo, é normal termos erros de CORS na hora de consumir e disponibilizar APIs.

Mas afinal, o que é CORS, o que causa os erros e como evitá-los em nossas APIs com Spring Boot?

CORS
O CORS é um mecanismo utilizado para adicionar cabeçalhos HTTP que informam aos navegadores para permitir que uma aplicação Web seja executada em uma origem e acesse recursos de outra origem diferente. Esse tipo de ação é chamada de requisição cross-origin HTTP. Na prática, então, ele informa aos navegadores se um determinado recurso pode ou não ser acessado.

Mas por que os erros acontecem? Chegou a hora de entender!

Same-origin policy
Por padrão, uma aplicação Front-end, escrita em JavaScript, só consegue acessar recursos localizados na mesma origem da solicitação. Isso acontece por conta da política de mesma origem (same-origin policy), que é um mecanismo de segurança dos Browsers que restringe a maneira de um documento ou script de uma origem interagir com recursos de outra origem. Essa política possui o objetivo de frear ataques maliciosos.

Duas URLs compartilham a mesma origem se o protocolo, porta (caso especificado) e host são os mesmos. Vamos comparar possíveis variações considerando a URL https://cursos.alura.com.br/category/programacao:
                     URL                                     Resultado	                   Motivo
https://cursos.alura.com.br/category/front-end	            Mesma origem	       Só o caminho difere
http://cursos.alura.com.br/category/programacao	            Erro de CORS	       Protocolo diferente (http)
https://faculdade.alura.com.br:80/category/programacao	    Erro de CORS           Host diferente

Agora, fica a dúvida: o que fazer quando precisamos consumir uma API com URL diferente sem termos problemas com o CORS? Como, por exemplo, quando queremos consumir uma API que roda na porta 8000 a partir de uma aplicação React rodando na porta 3000. Veja só!

Ao enviar uma requisição para uma API de origem diferente, a API precisa retornar um header chamado Access-Control-Allow-Origin. Dentro dele, é necessário informar as diferentes origens que serão permitidas para consumir a API, em nosso caso: Access-Control-Allow-Origin: http://localhost:3000.

É possível permitir o acesso de qualquer origem utilizando o símbolo *(asterisco): Access-Control-Allow-Origin: *. Mas isso não é uma medida recomendada, pois permite que origens desconhecidas acessem o servidor, a não ser que seja intencional, como no caso de uma API pública. Agora vamos ver como fazer isso no Spring Boot de maneira correta.

Habilitando diferentes origens no Spring Boot
Para configurar o CORS e habilitar uma origem específica para consumir a API, basta criar uma classe de configuração como a seguinte:

@Configuration
public class CorsConfiguration implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            .allowedOrigins("http://localhost:3000")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD", "TRACE", "CONNECT");
    }
}
http://localhost:3000 seria o endereço da aplicação Front-end e .allowedMethods os métodos que serão permitidos para serem executados. Com isso, você poderá consumir a sua API sem problemas a partir de uma aplicação Front-end.

PADRAO DTO muito usado em API para transmissao de dados (classes record).

Para saber mais: Java Record

Lançado oficialmente no Java 16, mas disponível desde o Java 14 de maneira experimental, o Record é um recurso que permite representar uma classe imutável, contendo apenas atributos, construtor e métodos de leitura, de uma maneira muito simples e enxuta.

Esse tipo de classe se encaixa perfeitamente para representar classes DTO, já que seu objetivo é apenas representar dados que serão recebidos ou devolvidos pela API, sem nenhum tipo de comportamento.

Para se criar uma classe DTO imutável, sem a utilização do Record, era necessário escrever muito código. Vejamos um exemplo de uma classe DTO que representa um telefone:

public final class Telefone {

    private final String ddd;
    private final String numero;

    public Telefone(String ddd, String numero) {
        this.ddd = ddd;
        this.numero = numero;
    }

    @Override
    public int hashCode() {
        return Objects.hash(ddd, numero);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        } else if (!(obj instanceof Telefone)) {
            return false;
        } else {
            Telefone other = (Telefone) obj;
            return Objects.equals(ddd, other.ddd)
              && Objects.equals(numero, other.numero);
        }
    }

    public String getDdd() {
        return this.ddd;
    }

    public String getNumero() {
        return this.numero;
    }
}

Agora com o Record, todo esse código pode ser resumido com uma única linha:

public record Telefone(String ddd, String numero){}

Muito mais simples, não?!

Por baixo dos panos, o Java vai transformar esse Record em uma classe imutável, muito similar ao código exibido anteriormente.

Mais detalhes sobre esse recurso podem ser encontrados na documentacao https://docs.oracle.com/en/java/javase/16/language/records.html

Mapear requisições POST em uma classe Controller;
Enviar requisições POST para a API utilizando o Insomnia;
Enviar dados para API no formato JSON;
Utilizar a anotação @RequestBody para receber os dados do corpo da requisição em um parâmetro no Controller;
Utilizar o padrão DTO (Data Transfer Object), via Java Records, para representar os dados recebidos em uma requisição POST.

CONFIGURANDO BANCO DE DADOS JPA.
Configure as dependencias necessárias no pom.xml compiando-as do spring initilizr
neste projeto: validation, MySQL Driver, Spring Data JPA, Flyway Migration

Configure em resources o arquivo application.properties da seguinte maneira:
spring.datasource.url=jdbc:mysql://localhost/vollmed_api
spring.datasource.username=root (ou nome do usuario)
spring.datasource.password=root (ou a senha do usuario)
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

Crie o schema/database no mysqlworkbench ou no terminal via linha de comando;

Para saber mais: arquivo properties ou yaml?
As configurações de uma aplicação Spring Boot são feitas em arquivos externos, sendo que podemos usar arquivo de propriedades ou arquivo YAML. Neste “Para saber mais”, vamos abordar as principais diferenças entre eles.

Arquivo de propriedades
Por padrão, o Spring Boot acessa as configurações definidas no arquivo application.properties, que usa um formato de chave=valor:
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/clinica
spring.datasource.username=root
spring.datasource.password=root
Cada linha é uma configuração única, então é preciso expressar dados hierárquicos usando os mesmos prefixos para nossas chaves, ou seja, precisamos repetir prefixos, neste caso, spring e datasource.

YAML Configuration
YAML é um outro formato bastante utilizado para definir dados de configuração hierárquica, como é feito no Spring Boot.

Pegando o mesmo exemplo do nosso arquivo application.properties, podemos convertê-lo para YAML alterando seu nome para application.yml e modificando seu conteúdo para:
spring:
    datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3306/clinica
        username: root
        password: root

Com YAML, a configuração se tornou mais legível, pois não contém prefixos repetidos. Além de legibilidade e redução de repetição, o uso de YAML facilita o armazenamento de variáveis de configuração de ambiente, conforme recomenda o 12 Factor App, uma metodologia bastante conhecida e utilizada que define 12 boas práticas para criar uma aplicação moderna, escalável e de manutenção simples. (https://12factor.net/)

Mas afinal, qual formato usar?
Apesar dos benefícios que os arquivos YAML nos trazem em comparação ao arquivo properties, a decisão de escolher um ou outro é de gosto pessoal. Além disso, não é recomendável ter ao mesmo tempo os dois tipos de arquivo em um mesmo projeto, pois isso pode levar a problemas inesperados na aplicação.

Caso opte por utilizar YAML, fique atento, pois escrevê-lo no início pode ser um pouco trabalhoso devido às suas regras de indentação.